\documentclass[a4paper,11pt]{kth-mag}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage{lmodern}
\usepackage{datetime}
\usepackage[utf8]{inputenc}
\usepackage[swedish,english]{babel}
\usepackage{modifications}
\usepackage{algorithm2e}
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{url}
\selectlanguage{swedish}
\title{Benchmarking Human Solving Methods for
           Rubik's cube}

\subtitle{Duis autem vel eum iruire dolor in hendrerit in
          vulputate velit esse molestie consequat, vel illum
          dolore eu feugiat null}

\author{Andreas Nilsson  anil9@kth.se\\Anton Spång  aspang@kth.se}
\date{\today}

\blurb{DD143X - Bachelor Thesis\\Supervisor: Michael Schliephake\\Examiner: Örjan Ekeberg}
\trita{TRITA xxx yyyy-nn}
\begin{document}
\frontmatter
\pagestyle{empty}
\removepagenumbers
\maketitle
\selectlanguage{english}
\begin{abstract}
  This is a skeleton for KTH theses. More documentation
  regarding the KTH thesis class file can be found in
  the package documentation.


\end{abstract}
\clearpage
\begin{foreignabstract}{swedish}
  Denna fil ger ett avhandlingsskelett.
  Mer information om \LaTeX-mallen finns i
  dokumentationen till paketet.
\end{foreignabstract}

\clearpage
\tableofcontents*
\mainmatter
\section{Terminology} 
	\begin{description}
		\item[Cubie] a miniature cube
		\item[Scramble] perfoming a amount of random operations on a solved cube to reach a non-solved state.
		\item[Layer] contains one side of the cube and one row of the four neighbouring sides 
		\item[Operation] Rotating one layer of the cube
		\item[Notation] a character that is a abbreviation of the operation-name.
	\end{description}

\pagestyle{newchap}
\chapter{Introduction}
\begin{figure}
	\centering
	\begin{subfigure}[b]{0.3\textwidth}
		\includegraphics[width=\textwidth]{figs/scramble.jpg}
		\caption{Scrambled cube}
		\label{fig_1}
	\end{subfigure}
	\begin{subfigure}[b]{0.3\textwidth}
		\includegraphics[width=\textwidth]{figs/DONE.png}
		\caption{Solved cube}
		\label{fig_2}
	\end{subfigure}
	\caption{}
\end{figure}

The Rubik’s cube is an 3-D combination puzzle, where each side of the cube is covered with nine squares in six possible colours: white, red, blue, orange, green and yellow. It was invented by the professor of architecture Ernő Rubik as a teaching tool to help his students to understand 3D objects. It was not until he scrambled his new cube and tried to restore it, that he realize that his creation was a puzzle. Originally the Rubik's cube was called the Magic Cube and was licensed to be sold by the american toy company Ideal Toy Company in 1980. \cite{Rubiks}.\\\\
When solving the cube the idea is to start with a scrambled cube, meaning that the colored miniature cubes (cubies) are randomly positioned by executing random operations on the cube (fig \ref{fig_1}). The goal is to obtain the unique solution where each side of the cube are covered with only one colour per side (fig \ref{fig_2}). Different methods have been developed to solve subproblems one at the time with a series of operations to reach the unique solution. Many methods are based on the idea to solve it one layer at the time.\\\\
If you were to randomly rotate the faces in an attempt to solve the cube, there is almost zero chance of achieving the solved state in your lifetime, because of all the possible permutations of the cube. There are $4.3 * 10^{19}$ (or 43 quintillion) \cite{Faculty} different states. Assuming you get to a unique state every second it would take more than 130 billion years to test 10\% of the cubes possible states [appendix A].\\\\
There are two major ways to compete in solving the Rubik’s cube: the least amount of moves and solving the cube as fast as possible (speedcubing).

\section{Problem}
This thesis will explore two commonly known beginner methods for human solving of Rubik’s cubes to find the differences. Both methods are based on the idea to solve the cube one layer at the time, which is the easiest way for the human mind to solve this kind of problem \cite{Lar5}. We will evaluate the methods operation variance and the number of operations to reach a solved state, to find the most move-efficient of them both.\\\\
The problem was stated as follows:
\begin{itemize}
\item[] Which of the beginner algorithms would be more effective for speedcubing?
\item[] Which of the beginner algorithms solves the cube with the least amount of moves?
\item[] Which beginner algorithm is easiest to learn and execute to someone inexperienced with the cube?
\end{itemize}
\section{Purpose}
The purpose of testing the methods is to find out which uses the least amount of moves and to find out which method suits speedcubing best by analyzing the usage of different operations. The reason the operations shows if the method is suitable for speedcubing is because some of the operations are more time-consuming than others. The inexperienced user will find this as a guideline as to which algorithm to start his/her journey towards solving the Rubik’s cube.
\section{Structure}
The second section will introduce the reader to concepts necessary to understand the algorithms implemented and benchmarked. The third section will explain the methods used in this thesis. The fourth sections will explain the implementations made in detail and the difficulties.\\
The fifth section will be for presenting the results and the sixth section for discussion regarding the results. After that will there be a conclusions section that completes the circle of the thesis, answering the problem statements. Lastly the references used to this thesis will be listed followed by appendix containing computations and graphs.  


\chapter{Background}
Providing the reader with knowledge of how the cube works and operations that you can perform on it as well as the algorithms that are in focus for this thesis.
\section{Competitions}
There are two types of competitions regarding the cube.
\paragraph{Speedcubing}
When competing in an official event regulated by the World Cube Association (WCA), the competitor has at maximum 15 seconds of inspection time of the cube before the solve begins.\cite{WCA2} The time stops when the competitor have reached the unique solution. 
\paragraph{Fewest moves}
The competitors have 60 minutes without any inspection time and the competitor should also be able to hand in a written solution with the notations used in the correct format \cite{WCA2}.
\section{Rubik's Cube}
Explanation of how the cube is constructed and the different notations for the operations.
\paragraph{Description}
The cube consists of 26 cubies with three,two or one visible sides depending on the type of cubie. There is one core piece consisting of three axes which holds the center pieces together \cite{MadeHow}. 
  The corner and edge pieces (fig \ref{fig_3})  are the cubies that are movable to different edge and corner positions, the center pieces (fig \ref{fig_3}) can only be moved according to the axis.  
\paragraph{Notation}
The notation describes the different move operations on the cube. This thesis uses the notation used by WCA. Explained below:\\
Clockwise 90 degrees:\\
F - Front face\\
B - Back face\\
R - Right face\\
L - Left face\\
U - Upper face\\
D - Bottom face\\
To denote the anti-clockwise 90 degrees rotation just put a single citation mark (‘) after the letter. For example F’ - move front face anti-clockwise 90 degrees.\cite{WCA1}
To denote clockwise 180 degrees rotation just put (2) after the letters described above. 
\begin{figure}[b]
	\centering
	\includegraphics[width= 0.5\textwidth]{figs/representation.png}
	\caption{Cubie types}
	\label{fig_3}
\end{figure}
\section{Algorithms}
The algorithms are physically methods for solving the cube by hand but matches the mathematical definition of an algorithm. Unlike many of the “near-optimal solvers” (some of simulates several moves ahead to find the optimal move\cite{Kociemba}), these algorithms can with little effort be taught to humans.
\paragraph{Layer-by-layer using daisy method}
\begin{figure}
	\centering
	\begin{subfigure}[!b]{0.3\textwidth}
		\includegraphics[width=\textwidth]{figs/step1.png}
		\caption{The white cross done}
		\label{fig_4}
	\end{subfigure}
	\begin{subfigure}[!b]{0.3\textwidth}
		\includegraphics[width=\textwidth]{figs/step2.png}
		\caption{First layer complete}
		\label{fig_5}
	\end{subfigure}
	\caption{}
\end{figure}
The layer-by-layer (LBL) algorithms divides the cube into layers and makes it possible to solve the subproblems without breaking any pieces already made. 
The daisy method is to solve the white cross by first make a cross with white edges and a yellow center and then turn the white edges, completing the white cross in the bottom \cite{Shellie}.
\subsubsection{1. White cross}
The goal here is to achieve a white cross, so that the white center-piece is aligned with its 4 white edge-pieces in the bottom. For it to be a completed step, the second color of the white edge-pieces must also align with it’s center-piece counterpart as shown in fig \ref{fig_4}. This is done by first making a cross on the top with the yellow center-piece and then flip the edges over to the bottom one at the time using an operation, to make sure the edge-pieces on the vertical sides are aligned with the center-pieces.
\subsubsection{2. White corners}
With the white cross done the next step is to complete the first layer by positioning the white corner-pieces correct between the cross edges (fig \ref{fig_5}). This is achieved with three different operation-combinations depending on the colour positions, all focusing on the upper-front-left corner of the cube.
\subsubsection{3. Middle layer edges}
The next step is to solve the middle layer by moving down a cubie from the middle of the third layer to the correct position on the second layer (fig \ref{fig_6}). 
\subsubsection{4. Yellow cross}
With the second layer complete (fig \ref{fig_7}) it is time to work on the yellow cross. This is achieved by applying one of two operation-combinations or both depending on how many white pieces that are correct positioned (fig \ref{fig_8}).  
\subsubsection{5. Yellow corners}
Positioning the yellow corners by applying different operations to move the edges depending och how many corners that are in position already. 
\subsubsection{6. Last layer permutation}
Now when the corners of the last layer are in position so that the top is all yellow, the only thing left to do is to positioning the pieces of the last layer so they match with the colours of the vertical sides. This is achived by applying three different operation-combinations depending on if its edges or corners that should switch places. 
\begin{figure}[h]
	\centering
	\begin{subfigure}[!b]{0.3\textwidth}
		\includegraphics[width=\textwidth]{figs/step32.png}
		\caption{Technique for each side}
		\label{fig_6}
	\end{subfigure}
	\begin{subfigure}[!b]{0.3\textwidth}
		\includegraphics[width=\textwidth]{figs/step31.png}
		\caption{Middle layer complete}
		\label{fig_7}
	\end{subfigure}\caption{}
\end{figure}
\begin{figure}[h]
	\centering
	\begin{subfigure}[!b]{0.3\textwidth}
		\includegraphics[width=\textwidth]{figs/step41.png}
	\end{subfigure}
	\begin{subfigure}[!b]{0.3\textwidth}
		\includegraphics[width=\textwidth]{figs/step42.png}
	\end{subfigure}
	\begin{subfigure}[!b]{0.3\textwidth}
		\includegraphics[width=\textwidth]{figs/step43.png}
	\end{subfigure}
	\caption{Different states to achive the yellow cross}
	\label{fig_8}
\end{figure}
\newpage
\paragraph{Dedmore algorithm}
The dedmore algorithm is also solving the cube layer-by-layer, but focusing on a corners-first solution\cite{Dedmore}. It was one of the first solution guides to the Rubik's cube\cite{Ijsat}. \\
\begin{figure}[b]
	\centering
	\begin{subfigure}[!b]{0.3\textwidth}
		\includegraphics[width=\textwidth]{figs/rubiks-frst-corner.jpg}
		\caption{First corner in position}
		\label{fig_9}
	\end{subfigure}
	\begin{subfigure}[!b]{0.3\textwidth}
		\includegraphics[width=\textwidth]{figs/rubiks-scnd-corner.jpg}
		\caption{Second corner in position}
		\label{fig_10}
	\end{subfigure}
	\begin{subfigure}[!b]{0.3\textwidth}
		\includegraphics[width=\textwidth]{figs/rubiks-4-corners.jpg}
		\caption{Top edges in position}
		\label{fig_11}
	\end{subfigure}
	\caption{}
\end{figure}

\subsubsection{1. Top corners (the X)}
Start off by finding a starting corner. For example aim to solve the blue top face first. Rotate the cube to obtain the blue side of the corner in top position. Then move the blue center-piece into position without moving your corner. When this is done, rotate the whole cube to obtain the corner in your top left on the front side, as in the fig \ref{fig_9}.\\\\
Next you’ll search for the next corner that should be positioned in the top right front side. Depending on the position on this corner, you will use different operation sequences to get it in position like the fig \ref{fig_10}.\\\\
Simply rotate the cube and continue on. The goal of this step is to form an ‘X’ on the top face as in fig \ref{fig_11}.
\subsubsection{2. Top edges}
The goal of this step is to simply get the edges in place. Get them in place one by one. When this step is finished the cube looks like fig \ref{fig_12}.
\subsubsection{3. Middle layer}
The next step is to solve the middle layer by moving down a cubie from the middle of the third layer to the correct position on the second layer (fig \ref{fig_6}). 

\subsubsection{4. Bottom corners}
Here the cube is turned upside down and the goal here is again to build a (green) X with the corners(fig \ref{fig_13}).
\subsubsection{5. Bottom edges}
In this step, at least one edge is already in the correct place (the color might be switched as in fig \ref{fig_14}). Find that edge and put it on the front side. Then position every other edge correctly by using a series of operations.\\\\
When every edge are correctly positioned, there are 2 possible states left. Each requires a different sequence of operations to solve. The ‘fish’ pattern (fig \ref{fig_15}) and the ‘H’ pattern (fig \ref{fig_16}). Execute the sequence for the pattern and you’ll then have solved the cube.
\begin{figure}[bh]
	\centering
	\begin{subfigure}[!b]{0.3\textwidth}
		\includegraphics[width=\textwidth]{figs/rubiks-top-edges.jpg}
		\caption{Top edges in position}
		\label{fig_12}
	\end{subfigure}
	\begin{subfigure}[!b]{0.3\textwidth}
		\includegraphics[width=\textwidth]{figs/rubiks-bottom-edges.jpg}
		\caption{The green X}
		\label{fig_13}
	\end{subfigure}
	\begin{subfigure}[!b]{0.3\textwidth}
		\includegraphics[width=\textwidth]{figs/last-edge-correct.jpg}
		\caption{One edges correctly placed}
		\label{fig_14}
	\end{subfigure}
	\caption{}
\end{figure}
\begin{figure}[bh]
	\centering
	\begin{subfigure}[!b]{0.3\textwidth}
		\includegraphics[width=\textwidth]{figs/fish-pattern.jpg}
		\caption{Fish pattern}
		\label{fig_15}
	\end{subfigure}
	\begin{subfigure}[!b]{0.3\textwidth}
		\includegraphics[width=\textwidth]{figs/H-pattern.jpg}
		\caption{H pattern}
		\label{fig_16}
	\end{subfigure}
	\caption{}
\end{figure}

\chapter{Method}
For this thesis the two major methods used where implementation of methods and analyzis of the data representation.
Both of the algorithms will be implemented in the same language and with the same built-in functions and data structures to rule out unnecessary differences, to obtain a realistic comparison in the end.
The algorithms needs to be executed a number of times to obtain a good set of data for the comparison. The data will be obtained during the executions by saving informations as number of moves used, statistics of moves used and number of times the method used least amount of moves to files.  
Based on the test data we will be able to evaluate each methods use of different operations, number of operations used and if suitable for speedcubing. The differences in used operations will provide information to evaluate if the times to solve are realistic for human solving. This depends on the usage of operations that are time-consuming for physical solving of the cube. 


\section{Cube representation}
 The cube is represented as six separate sides. Each side consists of nine positions each of which has a color (as in \ref{fig_17}). There exists no relation between positions in different sides; unlike the physical cube, where for example an edge has two colors. This means any correctly performed operation will need to move the colours to the correct side and location. The only way to keep the rules of the physical cube (correct colour-combination of a cubie) is to enforce them during the operations.\\\\
 For example performing the `F' operation (flip the front layer 90 degrees clockwise) on the cube shown in \ref{fig_17} would result in these internal assignments:
 \begin{verbatim}
		Side tempTop = new Side(top);
		Side tempFront = new Side(front);
		top.c7 = left.c9;
		top.c8 = left.c6;
		top.c9 = left.c3;
		left.c3 = bot.c1;
		left.c6 = bot.c2;
		left.c9 = bot.c3;
		bot.c1 = right.c7;
		bot.c2 = right.c4;
		bot.c3 = right.c1;
		right.c1 = tempTop.c7;
		right.c4 = tempTop.c8;
		right.c7 = tempTop.c9;
		front.c1 = tempFront.c7;
		front.c2 = tempFront.c4;
		front.c3 = tempFront.c1;
		front.c4 = tempFront.c8;
		front.c6 = tempFront.c2;
		front.c7 = tempFront.c9;
		front.c8 = tempFront.c6;
		front.c9 = tempFront.c3;
\end{verbatim}
\begin{figure}[b]
	\centering
	\includegraphics[width= 0.9\textwidth]{figs/cubeorder.jpg}
	\caption{Side numberings}
	\label{fig_17}
\end{figure}  
\section{Scramble}
The idea of the scrambler is to always start with a solved cube. The scramble is simulated by making a large amount of operations in pseudo-random sequence [Algorithm 1]. The scrambled cube is saved to a list awaiting the two solvers to pick and solve it.\\\\
\RestyleAlgo{boxed}
	\begin{algorithm}[H]
	\caption{Scramble}
	\KwIn{A cube, Number of operations to be made}
	\KwOut{A scrambled cube}
	Let rand be a psuedo-random generator.\\
	\For{Number of op to be made}{int opNr = rand.nextInt(Tot num of op)\\ \Switch{opNr}{ All operations represented by a number, perform the operation with the number opNr}}

	\end{algorithm}

\section{Method implementation}
	Both methods contains several steps and all of them uses the same structure. First look if the step already is done, else while it is not done perform operations given by the methods on the cube until the main operations of the step can be performed [Algorithm 2]. \\\\
	\RestyleAlgo{boxed}
	\begin{algorithm}[H]
	\caption{Method steps general idea}
	\KwIn{A cube}
	\KwOut{A cube that has a subproblem solved}
		\If{stepIsDone(cube)}{return cube}
		\While{not(stepIsDone(cube))}{\If{readyForOperations(cube)}{Perform the operations necessary to complete the step}\Else{\While{not(readyForOperations(cube))}{Operations to get the cube in a state to be able to perform the steps operations}}}
	\end{algorithm}

	
\chapter{Results and Analyze}
Containing visualisation of the data collected from the executions in form of graphs and description of what the graphs shows.\\\\ 

Fig \ref{fig_18} represents the sum of executions that used the same amount of moves, where the x-axis is amount of moves and the y-axis number of executions. 
As shown by the highest pillars for both methods, the Lbl with daisy method had a lower average (170) amount of moves than the dedmore method (188). Turning the whole cube in any direction was not counted for as a move.\\\\
Fig \ref{fig_19} represents a comparison of the number of executions the methods used least amount of moves, with the y-axis as number of executions. 
This shows that over ten thousand Scrambled cubes the Lbl with daisy method won 69\% of the time, they got equal amount of moves 1\% of the time and dedmore method had the fewest 30\% of the time.\\\\
Fig \ref{fig_20} represents the average use of operations for both methods over all executions with the x-axis as the average number of times the operations where used. \\The data for both fig \ref{fig_19} and fig \ref{fig_20} can be seen in Appendix B.\\\\ 

\begin{figure}[h!]
	\centering
	\includegraphics[width= 1.1\textwidth]{figs/graphone.png}
	\caption{}
	\label{fig_18}
\end{figure}
\begin{figure}[ht!]
	\centering
	\includegraphics[width= 1.0\textwidth]{figs/graphthree.png}
	\caption{}
	\label{fig_19}
\end{figure}
\begin{figure}[ht!]
	\centering
	\includegraphics[width= 1.0\textwidth]{figs/graphtwo.png}
	\caption{Average use of operations}
	\label{fig_20}
\end{figure}


\chapter{Discussion}

\section{Comparison}
As we can see in the results fig \ref{fig_18}, Lbl with daisy method has the lowest amount of moves the majority of the time. Lbl with daisy method also has the lowest minimum and maximum amount of moves with 95 and 253 respectively. The corresponding values for the Dedmore method are 96 and 292 REF TO DATA. This shows that Lbl wins in average, best case and worst case and the result of this is shown in fig \ref{fig_19}.\\\\
The methods often assumed the correct cubies to be on a certain side (in reality this simply means rotating the cube to desired position). The implemented versions prioritized execution of operations instead, to get the cube into position, which led to an increase in the total operations. This might explain the frequent uses of a few operations, for example U, Ui and F, shown in fig \ref{fig_20}.






 %To get a more clear understanding of why this is the case we observe fig \ref{fig_20}...?!?!?-.-
\section{Difficulty}
Converting the methods effeciently from description of physical solving of the cube to the code solver proved to be challenging. Ambigous and unfinished description of steps in the methods has led to an extra amount of operations on the cubes. This have had an impact on the final result.


\section{Errors}

\chapter{Conclusion}
\cite{MadeHow}
\renewcommand{\bibname}{References}
\bibliographystyle{plain}
\bibliography{references}

\appendix
\addappheadtotoc
\chapter{Calculation of randomly rotate faces}\label{appA}
Assumption: Every second you get to a new state.\\
There are $4.3*10^{19}$  different states (rounded down) \cite{Faculty}.
10\% of the different states:\\
$4.3*10^19*0.1=4.3*10^{18}$ \\
4.31018 seconds to years = 136.4109 years
\cite{Wolfram}

\label{App:AppendixB}
\chapter{Data}
	
		Average use of operations.\\
		\begin{tabular}{|l|l|l|}
		\hline
		Operations & Lbl & Dedmore \\ \hline
		D & 1.0365 & 11.3665 \\ \hline
		E & 0.1103 & 6.0217 \\ \hline
		F & 36.4211 & 10.7248 \\ \hline
		B & 3.2228 & 0.0718 \\ \hline
		Ri & 15.1558 & 16.7828 \\ \hline
		L & 2.8949 & 8.8148 \\ \hline
		M & 0.000 &	6.1479 \\ \hline
		Ui & 18.122 & 37.7467 \\ \hline
		U & 36.0845 & 24.2097 \\ \hline
		Bi & 3.2228 & 0.0955 \\ \hline
		Mi & 0.000 & 6.1479 \\ \hline
		Li & 2.8949 & 8.7691 \\ \hline
		R & 25.2278 & 12.7341 \\ \hline
		Ei & 4.5369 & 13.2933 \\ \hline
		Fi & 15.1163 & 9.2282 \\ \hline
		Di & 6.3726 & 16.5212 \\ \hline
		\end{tabular}
		\\
		
		Number of times the algorithms had least amount of moves.\\
		\begin{tabular}{|l|l|l|}
		\hline
		Lbl & Dedmore & Equals \\ \hline
		6935 & 2960 & 105 \\ \hline
		\end{tabular}
	
\end{document}
